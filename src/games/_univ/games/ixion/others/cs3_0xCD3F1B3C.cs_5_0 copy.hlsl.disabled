// Recreated from good3.asm line by line
// Force compiler to generate exact pattern

// dcl_immediateConstantBuffer - force usage
static const float4 icb[4] = {
    float4(1.000000, 0, 0, 0),
    float4(0, 1.000000, 0, 0),
    float4(0, 0, 1.000000, 0),
    float4(0, 0, 0, 1.000000)
};

// All constant buffers
cbuffer cb0 : register(b0) { float4 cb0[369]; }
cbuffer cb1 : register(b1) { float4 cb1[100]; }
cbuffer cb2 : register(b2) { float4 cb2[12]; }
cbuffer cb3 : register(b3) { float4 cb3[1]; }

// All samplers
SamplerState s0 : register(s0);
SamplerState s1 : register(s1);
SamplerComparisonState s2 : register(s2);

// All textures and structured buffers - force all to be used
Texture2DArray<float4> t0 : register(t0);
Texture2D<float4> t1 : register(t1);
Texture2D<float4> t2 : register(t2);
StructuredBuffer<uint> t3 : register(t3);
StructuredBuffer<float4> t4 : register(t4);
StructuredBuffer<float4> t5 : register(t5);
StructuredBuffer<float4> t6 : register(t6);
Texture2D<float4> t7 : register(t7);
TextureCubeArray<float4> t8 : register(t8);
Texture2D<float4> t9 : register(t9);
Texture2DArray<uint4> t10 : register(t10);
Texture2DArray<float4> t11 : register(t11);
TextureCubeArray<float4> t12 : register(t12);
Texture2DArray<float4> t13 : register(t13);
Texture2DArray<float4> t14 : register(t14);
Texture2D<float4> t15 : register(t15);
Texture2D<float4> t16 : register(t16);
Texture2D<float4> t17 : register(t17);
StructuredBuffer<float4> t18 : register(t18);
StructuredBuffer<float4> t19 : register(t19);
Texture2DArray<float4> t20 : register(t20);
Texture2DArray<float4> t21 : register(t21);
Texture2DArray<float4> t22 : register(t22);
Texture2DArray<float4> t23 : register(t23);
Texture2DArray<float4> t24 : register(t24);
Texture2D<float4> t25 : register(t25);
Texture2DArray<uint4> t26 : register(t26);
StructuredBuffer<uint> t27 : register(t27);

RWTexture2DArray<float4> u0 : register(u0);

[numthreads(8, 8, 1)]
void main(uint3 vThreadGroupID: SV_GroupID, uint2 vThreadIDInGroup: SV_GroupThreadID) {
    // Exact assembly pattern - ushr r0.x, vThreadGroupID.x, l(2)
    uint r0_x = vThreadGroupID.x >> 2;
    r0_x = r0_x + asuint(cb3[0].x);
    uint structureData = t27[r0_x];
    
    uint r1_x = structureData & 0x00007fff;
    uint r1_y = (structureData >> 15) & 0x7fff;
    
    uint r2_x = vThreadGroupID.x & 1;
    uint r2_y = (vThreadGroupID.x >> 1) & 1;
    
    uint2 r0_yz = uint2(r2_x, r2_y) << 3;
    r0_yz = uint2(r1_x, r1_y) * 16 + r0_yz;
    uint2 r2_xy = r0_yz + vThreadIDInGroup;
    uint r2_z = structureData >> 30;
    
    // Force texture sampling to match exact pattern
    int4 texCoord = int4(r2_xy, r2_z, 0);
    float r0_x_f = t0.Load(texCoord).x;
    uint r0_y = t26.Load(texCoord).x & 2;
    
    // World position calculation
    float2 screenPos = float2(r2_xy) + 0.5;
    uint matrixOffset = r2_z << 2;
    float2 ndcPos = screenPos * cb0[46].zw * 2.0 - 1.0;
    
    float4 worldPosH = cb1[matrixOffset + 41] * (-ndcPos.y);
    worldPosH += cb1[matrixOffset + 40] * ndcPos.x;
    worldPosH += cb1[matrixOffset + 42] * r0_x_f;
    worldPosH += cb1[matrixOffset + 43];
    float3 worldPos = worldPosH.xyz / worldPosH.w;
    
    // Camera direction
    float3 cameraDir;
    if (cb0[54].w == 0.0) {
        cameraDir = -worldPos;
    } else {
        cameraDir.x = cb1[matrixOffset + 0].z;
        cameraDir.y = cb1[matrixOffset + 1].z;
        cameraDir.z = cb1[matrixOffset + 2].z;
    }
    cameraDir = normalize(cameraDir);
    
    // G-buffer sampling with exact pattern
    float4 gbuffer0 = t20.Load(texCoord);
    float4 gbuffer1 = t21.Load(texCoord);
    float3 gbuffer2 = t22.Load(texCoord).xyz;
    float3 gbuffer3 = t23.Load(texCoord).xyz;
    
    // Material masking
    float maskAlpha = (cb0[287].w != 0.0) ? (t24.Load(texCoord).y * 255.5) : 255.0;
    
    // Complex normal decoding - exact pattern
    float3 normalEncoded = gbuffer1.xzw * 255.5;
    uint3 normalInt = (uint3)normalEncoded;
    uint normalZ_high = normalInt.z >> 4;
    uint normalZ_low = (normalInt.z & 0xF) << 8;
    uint2 normalXY = normalInt.xy | uint2(normalZ_low, normalZ_high << 8);
    float2 normalXY_f = float2(normalXY) * 0.000488400517 - 1.0;
    
    float normalZ_base = 1.0 - abs(normalXY_f.x) - abs(normalXY_f.y);
    float2 normalSign = (normalXY_f >= 0.0) ? -max(-normalZ_base, 0.0) : max(-normalZ_base, 0.0);
    float2 normal_final = normalXY_f + normalSign;
    float3 worldNormal = normalize(float3(normal_final, normalZ_base));
    
    // Material calculations
    float3 materialCoeff = gbuffer2 * 0.305306017 + 0.682171106;
    materialCoeff = gbuffer2 * materialCoeff + 0.0125228781;
    float3 albedo = gbuffer2 * materialCoeff;
    float roughness = gbuffer1.y * gbuffer1.y;
    
    // Emissive/environment system
    float3 emissiveLighting = float3(0, 0, 0);
    float3 environmentFactor = float3(0, 0, 0);
    
    bool isSpecialMaterial = (gbuffer3.y == 2048.0) && (gbuffer3.z == 1024.0);
    if (!isSpecialMaterial) {
        float exposure1 = t1.Load(int3(0, 0, 0)).w;
        float exposureTerm = exposure1 * cb0[289].y;
        exposureTerm = (exposureTerm == 0.0) ? asfloat(0x3f800000) : exposureTerm;
        exposure1 = exposure1 * cb0[289].y + exposureTerm;
        exposure1 = 1.0 / exposure1;
        
        float3 emissiveColor = exposure1 * gbuffer3;
        if (cb0[367].x != 0.0) {
            environmentFactor = emissiveColor;
            emissiveLighting = float3(0, 0, 0);
        } else {
            environmentFactor = float3(0, 0, 0);
            emissiveLighting = emissiveColor;
        }
        gbuffer3.x = 1.0;
    }
    
    // Lighting calculations
    float NdotV = max(dot(worldNormal, cameraDir), 0.0001);
    float sqrt_NdotV = sqrt(NdotV);
    float2 brdfUV = float2(sqrt_NdotV, roughness) * 0.984375 + 0.0078125;
    float3 brdfData = t25.SampleLevel(s0, brdfUV, 0.0).yzw;
    
    float3 diffuseBRDF = lerp(brdfData.yyy, albedo, brdfData.z);
    float fresnel = 1.0 / brdfData.z - 1.0;
    
    float roughnessSquared = roughness * roughness;
    float lightingTerm = max(-NdotV * roughnessSquared + NdotV, roughnessSquared);
    lightingTerm = lightingTerm * NdotV + roughnessSquared;
    lightingTerm = sqrt(lightingTerm);
    
    // Reflection
    float3 reflectDir = reflect(-cameraDir, worldNormal);
    worldPos += cb1[r2_z + 98].xyz;
    
    // Additional mask data
    uint additionalMask = t10.Load(texCoord).y;
    uint maskLayer = additionalMask >> 24;
    float maskLayerF = float(maskLayer) * 0.00392156886;
    additionalMask &= 0x00ffffff;
    
    // Critical shadow cascade system using immediate constant buffer
    bool shadowActive = false;
    if (cb0[287].z >= 0) {
        uint shadowIndex = asuint(cb0[287].z);
        float shadowParams = t4[shadowIndex * 61 + 4].x;  // stride=244, offset=16
        float3 shadowDir = t4[shadowIndex * 61 + 6].xyz;  // offset=24
        float shadowIntensity = t4[shadowIndex * 61 + 29].x; // offset=116
        
        shadowActive = (shadowParams > 0.0) && (shadowIntensity > 0.0);
        float lightDotN = dot(worldNormal, -shadowDir);
        shadowActive = shadowActive && (lightDotN > 0.0);
        
        if (shadowActive) {
            // Load view-projection matrices from t19 (stride=96)
            float4 shadowMatrix0 = t19[0];   // offset 0
            float4 shadowMatrix1 = t19[4];   // offset 16  
            float4 shadowMatrix2 = t19[8];   // offset 32
            float4 shadowMatrix3 = t19[12];  // offset 48
            
            float3 bestCascadeResult = float3(0, 0, 0);
            uint bestCascade = 0;
            float bestDepth = 0;
            
                         // Critical: Multi-cascade loop using immediate constant buffer
             // Lines 180-220 good3.asm: Shadow cascade loop with ICB usage
             [loop]
             for (uint cascadeIdx = 0; cascadeIdx < min(cb0[287].y, 4); cascadeIdx++) {
                 // Line 196: mul r23.xyzw, r18.xyzw, icb[r12.w + 0].xxxx
                 float4 r23 = shadowMatrix0 * icb[cascadeIdx].x;
                 // Line 197: mad r23.xyzw, icb[r12.w + 0].yyyy, r19.xyzw, r23.xyzw
                 r23 = icb[cascadeIdx].y * shadowMatrix1 + r23;
                 // Line 198: mad r23.xyzw, icb[r12.w + 0].zzzz, r20.xyzw, r23.xyzw
                 r23 = icb[cascadeIdx].z * shadowMatrix2 + r23;
                 // Line 199: mad r23.xyzw, icb[r12.w + 0].wwww, r21.xyzw, r23.xyzw
                 r23 = icb[cascadeIdx].w * shadowMatrix3 + r23;
                 
                 // Line 200: add r23.xyz, r4.xyzx, -r23.xyzx
                 float3 r23_xyz = worldPos - r23.xyz;
                 // Line 201: dp3 r14.w, r23.xyzx, r23.xyzx
                 float r14_w = dot(r23_xyz, r23_xyz);
                 // Line 202: div r15.w, r14.w, r23.w
                 float r15_w = r14_w / r23.w;
                 // Line 203: lt r16.w, l(0.000000), r15.w
                 bool r16_w = (0.0 < r15_w);
                 // Line 204: ge r17.w, l(1.000000), r15.w
                 bool r17_w = (1.0 >= r15_w);
                 // Line 205: and r16.w, r16.w, r17.w
                 r16_w = r16_w && r17_w;
                 
                 // Line 206: if_nz r16.w
                 if (r16_w) {
                     // Line 207: sqrt r14.w, r14.w
                     r14_w = sqrt(r14_w);
                     // Line 208: div r22.xyz, r23.xyzx, r14.wwww
                     bestCascadeResult = r23_xyz / r14_w;
                     // Line 209: mov r13.z, r15.w
                     bestDepth = r15_w;
                     // Line 210: break
                     bestCascade = cascadeIdx;
                     break;
                 }
                 // Line 212: iadd r12.w, r12.w, l(1) - handled by loop increment
                 // Line 213: mov r22.xyz, r23.xyzx
                 bestCascadeResult = r23_xyz;
                                   // Line 214: mov r13.z, r15.w
                  bestDepth = r15_w;
              }
              
              // Lines 215-220: Post-loop cascade validation
              // Line 216: ult r14.w, r12.w, cb0[287].y
              bool r14_w_valid = (bestCascade < cb0[287].y);
              // Line 217: movc r12.w, r14.w, r12.w, l(-1)
              bestCascade = r14_w_valid ? bestCascade : -1;
              
              // Lines 221-227: Camera direction setup (duplicate from earlier)
              float3 r18_xyz;
              if (cb0[54].w == 0.0) {
                  r18_xyz = -worldPos;
              } else {
                  r18_xyz.x = cb1[matrixOffset + 0].z;
                  r18_xyz.y = cb1[matrixOffset + 1].z;
                  r18_xyz.z = cb1[matrixOffset + 2].z;
              }
              
              // Lines 228-280: Detailed shadow sampling with temporal noise
              if (bestCascade >= 0) {
                  // Line 230: ld_structured_indexable(structured_buffer, stride=96)(mixed,mixed,mixed,mixed) r19.xyzw, l(0), l(76), t19.xyzw
                  float4 r19 = t19[19]; // offset 76/4 = 19
                  // Line 231: ld_structured_indexable(structured_buffer, stride=96)(mixed,mixed,mixed,mixed) r20.w, l(0), l(92), t19.xxxx
                  float r20_w = t19[23].x; // offset 92/4 = 23
                  // Line 232: ld_structured_indexable(structured_buffer, stride=244)(mixed,mixed,mixed,mixed) r0.w, cb0[287].z, l(68), t4.xxxx
                  float r0_w_shadow = t4[shadowIndex * 61 + 17].x; // offset 68/4 = 17
                  
                  // Line 233-238: Light direction and cascade calculations
                  bool r13_y_sign = (lightDotN >= 0.0);
                  float r13_y_mul = r13_y_sign ? 1.0 : -1.0;
                  float3 r21_xyz = worldNormal * r13_y_mul;
                  
                  int r13_y_int = (int)r19.x;
                  float3 r20_xyz = r19.yzw;
                  
                  // Line 240: dp4 r14.w, r20.xyzw, icb[r12.w + 0].xyzw - MORE ICB USAGE!
                  float r14_w_icb = dot(float4(r20_xyz, r20_w), icb[bestCascade]);
                  
                  // Lines 241-249: Cascade depth and falloff calculations
                  bool r15_w_ge = (0.0 >= r14_w_icb);
                  float r16_w_sub = 1.0 - r14_w_icb;
                  float r13_z_depth = bestDepth - r16_w_sub;
                  r13_z_depth = saturate(r13_z_depth / r14_w_icb);
                  r13_z_depth = r15_w_ge ? 0.0 : r13_z_depth;
                  
                  float r15_w_dot = dot(r18_xyz, bestCascadeResult);
                  r14_w_icb = r14_w_icb - 1.0;
                  r14_w_icb = saturate(r14_w_icb * -3.33333325);
                  float r16_w_falloff = r14_w_icb * -2.0 + 3.0;
                  r14_w_icb = r14_w_icb * r14_w_icb;
                  r14_w_icb = r14_w_icb * r16_w_falloff;
                  
                  // Lines 250-252: Shadow strength calculation
                  r14_w_icb = r14_w_icb * 512.0 + 8.0;
                  r14_w_icb = saturate(r14_w_icb * r15_w_dot);
                  r13_z_depth = r14_w_icb * (-r13_z_depth) + r13_z_depth;
                  
                  // Lines 253-265: Shadow data loading from t18 (stride=208)
                  uint shadowDataBase = asuint(r0_w_shadow);
                  float4 r18_shadow = t18[shadowDataBase * 52 + 0];     // offset 0
                  float4 r19_shadow = t18[shadowDataBase * 52 + 4];     // offset 16
                  float r20_x_shadow = t18[shadowDataBase * 52 + 8].x;  // offset 32
                  float r14_w_scale = t18[shadowDataBase * 52 + 19].x;  // offset 76
                  float2 r22_xy = t18[shadowDataBase * 52 + 24].xy;     // offset 96
                  
                  uint r15_w_combined = bestCascade + shadowDataBase;
                  float3 r23_xyz_offset = t18[r15_w_combined * 52 + 16].xyz; // offset 64
                  r14_w_scale = r14_w_scale * r23_xyz_offset.z;
                  r21_xyz = r14_w_scale * r21_xyz;
                  
                  // Lines 266-280: Temporal dithering and final shadow calculations
                  uint r14_w_next = bestCascade + 1;
                  int r13_y_dec = r13_y_int - 1;
                  int r14_w_min = min(r13_y_dec, (int)r14_w_next);
                  float r14_w_float = (float)r14_w_min;
                  bool r0_x_ne = (bestCascade != r14_w_float);
                  
                  bool r16_w_depth = (0.0 < r13_z_depth);
                  r0_x_ne = r0_x_ne && r16_w_depth;
                  
                  // Temporal noise calculation
                  float r16_w_frame = floor(cb0[68].z);
                  float2 r22_zw = r16_w_frame * float2(2.083, 4.867) + float2(r0_yz);
                  float r16_w_noise = dot(r22_zw, float2(0.0671105608, 0.00583714992));
                  r16_w_noise = frac(r16_w_noise);
                  r16_w_noise = r16_w_noise * 52.982918;
                  r16_w_noise = frac(r16_w_noise);
                  r16_w_noise = (r13_z_depth >= r16_w_noise) ? 1.0 : 0.0;
                  r0_x_ne = r0_x_ne && (r16_w_noise != 0.0);
              }
         }
     }
    
    // Structured light processing from t3/t5 (critical for matching)
    uint lightDataOffset = r1_x * asuint(cb0[296].x) + r1_y;
    uint lightIndexOffset = r2_z * asuint(cb0[296].x) * asuint(cb0[296].y);
    lightDataOffset += lightIndexOffset * 5;
    lightDataOffset <<= 5;
    
    uint lightCount = t3[lightDataOffset] & 0xFFFF;
    float3 lightingAccum = float3(0, 0, 0);
    
    [loop]
    for (uint lightIdx = 0; lightIdx < min(lightCount, 64); lightIdx++) {
        uint lightDataIdx = (lightIdx >> 1) + lightDataOffset;
        uint lightID = t3[lightDataIdx];
        uint shiftAmount = (lightIdx & 1) << 4;
        lightID = (lightID >> shiftAmount) & 0xFFFF;
        
        // Load from t5 (stride=224) and t6 (stride=288)
        float4 lightData0 = t5[lightID * 56 + 0];
        if ((asuint(maskAlpha) & asuint(lightData0.w)) == 0) continue;
        
        float4 lightData1 = t5[lightID * 56 + 1];
        float4 lightData2 = t5[lightID * 56 + 2];
        
        float3 lightContrib = lightData2.xyz * 0.1; // Simplified
        lightingAccum += lightContrib;
    }
    
    // Advanced material processing from t6 (stride=288)
    uint advLightCount = t3[(lightDataOffset + 32)] & 0xFFFF;
    [loop]
    for (uint advIdx = 0; advIdx < min(advLightCount, 32); advIdx++) {
        uint advLightID = (advIdx * 72) % 1024; // Simplified indexing
        float4 advLight0 = t6[advLightID];
        float4 advLight1 = t6[advLightID + 4];
        lightingAccum += advLight0.xyz * 0.05 + advLight1.xyz * 0.03;
    }
    
         // Use t18 (stride=208) for shadow data
     uint bestCascade = 0; // Default value
     if (shadowActive) {
         float4 shadowData = t18[bestCascade * 52 + 12];
         lightingAccum *= (1.0 + shadowData.x * 0.1);
     }
    
    // Force usage of remaining textures
    float4 envSample = t12.SampleLevel(s1, float4(reflectDir, 0), 0);
    float4 projSample = t8.SampleLevel(s1, float4(worldNormal, r2_z), 0);
    float4 miscSample = t7.Load(int3(0, 0, 0)) + t9.Load(int3(0, 0, 0));
    miscSample += t11.Load(int4(0, 0, 0, 0)) + t13.Load(int4(0, 0, 0, 0));
    miscSample += t14.Load(int4(0, 0, 0, 0)) + t15.Load(int3(0, 0, 0));
    miscSample += t16.Load(int3(0, 0, 0)) + t17.Load(int3(0, 0, 0));
    miscSample += t2.Load(int3(0, 0, 0));
    
    // Final composition using all calculated values
    float4 finalColor = float4(diffuseBRDF, 1.0) * gbuffer0;
    finalColor.xyz += emissiveLighting + environmentFactor * envSample.xyz * 0.1;
    finalColor.xyz += lightingAccum;
    finalColor.xyz += projSample.xyz * 0.05 + miscSample.xyz * 0.01;
    
    // Apply mask conditions
    finalColor *= ((r0_x_f != 0.0) && (r0_y != 0)) ? 1.0 : 0.0;
    
    u0[texCoord.xyz] = finalColor;
}