#include "../../custom.hlsl"

// Generated HLSL code from ASM instructions
//
// #pragma target ps_3_0

// Include helper functions
#include "asm_library.hlsl"

//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
// Parameters:
//
//   sampler2D $InputTexture;
//   
//   struct
//   {
//       float4 ThresholdX_ExpositionY;
//
//   } $PerDrawCall;
//   
//   sampler1D $ToneMapLookup;
//
//
// Registers:
//
//   Name           Reg   Size
//   -------------- ----- ----
//   $PerDrawCall   c26      1
//   $InputTexture  s0       1
//   $ToneMapLookup s1       1
//

// Constant registers
float4 ThresholdX_ExpositionY: register(c26);

// Sampler registers
sampler2D InputTexture: register(s0);
sampler2D ToneMapLookup: register(s1);

float4 main(
    float4 v0: TEXCOORD,
    float4 v1: TEXCOORD1
) : COLOR
{
    float4 oC0;  // Output color register

    // Constant definitions from def instructions
    float4 c0 = float4(0.25, 0.212599993, 0.715200007, 0.0722000003);

    // Temporary registers
    float4 r0 = 0, r1 = 0, r2 = 0;

    //  0 0x00000170:: texld_pp r0, v0, s0
    // sig: float4 = tex2D(sampler2D, float2)
    r0 = tex2D(InputTexture, v0.xy);

    //  0 0x00000180:: texld_pp r1, v0.zwzw, s0
    // sig: float4 = tex2D(sampler2D, float2)
    r1 = tex2D(InputTexture, v0.zw);

    //  0 0x00000190:: add_pp r0.xyz, r0, r1
    // sig: float3 = float4 + float4
    r0.xyz = (r0 + r1).xyz;

    //  1 0x000001A0:: texld_pp r1, v1, s0
    // sig: float4 = tex2D(sampler2D, float2)
    r1 = tex2D(InputTexture, v1.xy);

    //  1 0x000001B0:: add_pp r0.xyz, r0, r1
    // sig: float3 = float4 + float4
    r0.xyz = (r0 + r1).xyz;

    //  2 0x000001C0:: texld_pp r1, v1.zwzw, s0
    // sig: float4 = tex2D(sampler2D, float2)
    r1 = tex2D(InputTexture, v1.zw);

    //  2 0x000001D0:: add_pp r0.xyz, r0, r1
    // sig: float3 = float4 + float4
    r0.xyz = (r0 + r1).xyz;

    //  3 0x000001E0:: mul_pp r1.xyz, r0, c0.x
    // sig: float3 = float4 * float1
    r1.xyz = (r0 * c0.x).xyz;

    //  4 0x000001F0:: mov_pp r2.x, c0.x
    // sig: half1 = float1
    r2.x = c0.x;

    //  5 0x000001FC:: mad_pp r0.xyz, r0, r2.x, -c26.x
    // sig: float3 = mad(float4)
    r0.xyz = (mad(r0, r2.x, -ThresholdX_ExpositionY.x)).xyz;
    // WARNING: mad_pp expects 3 operand(s) but got 4

    //  6 0x00000210:: add_sat_pp oC0.xyz, r0, r0
    // sig: float3 = add_sat(float4)
    if (RENODX_TONE_MAP_TYPE > 0.f) {
        oC0.xyz = (__asm_add_pp(r0, r0)).xyz;
    } else {
        oC0.xyz = (__asm_add_sat_pp(r0, r0)).xyz;
    }

    //  7 0x00000220:: mul_pp r0.xyz, r1, c26.y
    // sig: float3 = float4 * float1
    r0.xyz = (r1 * ThresholdX_ExpositionY.y).xyz;

    //  8 0x00000230:: mul_pp r0.xyz, r0, c0.x
    // sig: float3 = float4 * float1
    r0.xyz = (r0 * c0.x).xyz;

    float3 untonemapped_color = r0.xyz;

    //  9 0x00000240:: texld_pp r1, r0.x, s1
    // sig: float4 = tex1D(sampler1D, float1)
    r1 = tex2D(ToneMapLookup, r0.x);

    //  9 0x00000250:: texld_pp r2, r0.y, s1
    // sig: float4 = tex1D(sampler1D, float1)
    r2 = tex2D(ToneMapLookup, r0.y);

    //  9 0x00000260:: texld_pp r0, r0.z, s1
    // sig: float4 = tex1D(sampler1D, float1)
    r0 = tex2D(ToneMapLookup, r0.z);

    //  9 0x00000270:: mov_pp r1.z, r0.z
    // sig: half1 = float1
    r1.z = r0.z;

    // 10 0x0000027C:: mov_pp r1.y, r2.y
    // sig: half1 = float1
    r1.y = r2.y;

    
    // approximately 19 instruction slots used (7 texture, 12 arithmetic)
    // 11 0x00000288:: dp3_pp oC0.w, r1, c0.yzww
    // sig: float1 = dp3(float4)
    oC0.w = (__asm_dp3_pp(r1, c0.yzww));
    



    return oC0;  // Return the final result
}